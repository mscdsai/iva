# -*- coding: utf-8 -*-
"""iva.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l6tNqe44AqVOa2HFE56DCuMRiU7R4hGq
"""

# Practical 03 : Resizing Images and checking data types of Images
# Display The Image
import cv2
from google.colab.patches import cv2_imshow

# Path to your image file
image_path = '/content/review-banner-03.jpg'

img = cv2.imread(image_path)
print('Original Image')
cv2_imshow(img)
height , widht = img.shape[:2]
print(f'height * widht = {height} x {widht}')

print('resizing into small image')
# Resize the image  (small size)
new_width = int(img.shape[1] * 0.5)
new_height = int(img.shape[0] * 0.5)

resized_img = cv2.resize(img, (new_width, new_height))

cv2_imshow(resized_img)

height , widht = resized_img.shape[:2]
print(f'height * widht = {height} x {widht}')

image_dataType = img.dtype
print(image_dataType)


# Resize the image (larger size)
new_width1 = int(img.shape[1] * 2)
new_height2 = int(img.shape[0] * 2)

resized_img2 = cv2.resize(img, (new_width1, new_height2))

cv2_imshow(resized_img2)

height , widht = resized_img2.shape[:2]
print(f'height * widht = {height} x {widht}')

image_dataType = img.dtype
print(image_dataType)



######################### Converting Image into Gray Scale and then Resizing images
gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
print(gray_img)
cv2_imshow(gray_img)


print('resizing into small image')
# Resize the image  (small size)
new_width = int(gray_img.shape[1] * 0.5)
new_height = int(gray_img.shape[0] * 0.5)

resized_img = cv2.resize(gray_img, (new_width, new_height))

cv2_imshow(resized_img)

height , widht = resized_img.shape[:2]
print(f'height * widht = {height} x {widht}')

image_dataType = gray_img.dtype
print(image_dataType)


# Resize the image (larger size)
new_width1 = int(gray_img.shape[1] * 2)
new_height2 = int(gray_img.shape[0] * 2)

resized_img2 = cv2.resize(gray_img, (new_width1, new_height2))

cv2_imshow(resized_img2)

height , widht = resized_img2.shape[:2]
print(f'height * widht = {height} x {widht}')

image_dataType = gray_img.dtype
print(image_dataType)

########################### Using Simple thersholding Method (to Binary Image)
# Threshold the grayscale image to create a binary image
# Using a simple thresholding method
_, binary_img = cv2.threshold(gray_img, 128, 255, cv2.THRESH_BINARY)
print(binary_img)
cv2_imshow(binary_img)

print('resizing into small image')
# Resize the image  (small size)
new_width = int(binary_img.shape[1] * 0.5)
new_height = int(binary_img.shape[0] * 0.5)

resized_img = cv2.resize(binary_img, (new_width, new_height))

cv2_imshow(resized_img)

height , widht = resized_img.shape[:2]
print(f'height * widht = {height} x {widht}')

image_dataType = binary_img.dtype
print(image_dataType)


# Resize the image (larger size)
new_width1 = int(binary_img.shape[1] * 2)
new_height2 = int(binary_img.shape[0] * 2)

resized_img2 = cv2.resize(binary_img, (new_width1, new_height2))

cv2_imshow(resized_img2)

height , widht = resized_img2.shape[:2]
print(f'height * widht = {height} x {widht}')

image_dataType = binary_img.dtype
print(image_dataType)

# Practical 04 :- Basic Geometric Operation using OpenCV
import cv2
from google.colab.patches import cv2_imshow
# Display The Image

# Path to your image file
image_path = '/content/review-banner-03.jpg'

img = cv2.imread(image_path)
# Use only the thresholded image from the output of cv2.threshold
_, img2 = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY)

# 4. Draw line.
cv2.line(img2, (0, 0), (100, 100), (255, 0, 0), 5)

# 5. Draw Arrowed Line.
cv2.arrowedLine(img2, (0, 100), (100, 0), (0, 255, 0), 5)

# 6. Draw Rectangle.
cv2.rectangle(img2, (0, 100), (100, 200), (0, 0, 255), 5)

# 7. Draw Circle.
cv2.circle(img2, (50, 50), 20, (255, 255, 0), 5)

# 8. Draw text on the image.
cv2.putText(img2, 'Hello World', (100, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)

# Display the image
cv2_imshow(img2)

# Practical 05 :- To Apply Image Enhancement Techniques
import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Path to your image file (ensure the image is located at this path)
image_path = '/content/review-banner-03.jpg'

# Load the image in color
color_img = cv2.imread(image_path)

# Check if the image was loaded correctly
if color_img is None:
    raise FileNotFoundError("The image file was not loaded correctly. Please check the file path.")

# Convert the color image to grayscale
gray_img = cv2.cvtColor(color_img, cv2.COLOR_BGR2GRAY)

# Create an all-black image with the same dimensions as the color image
black_img = np.zeros_like(color_img)

# Display the original color, grayscale, and black images
print("Original Color Image:")
cv2_imshow(color_img)
print("Original Grayscale Image:")
cv2_imshow(gray_img)
print("All Black Image:")
cv2_imshow(black_img)

# Adjust brightness and contrast
def adjust_brightness_contrast(img, brightness=0, contrast=0):
    img = np.int16(img)
    img = img * (contrast / 127 + 1) - contrast + brightness
    img = np.clip(img, 0, 255)
    img = np.uint8(img)
    return img

brightness = 30
contrast = 50

adjusted_color_img = adjust_brightness_contrast(color_img, brightness, contrast)
adjusted_gray_img = adjust_brightness_contrast(gray_img, brightness, contrast)
adjusted_black_img = adjust_brightness_contrast(black_img, brightness, contrast)

# Display adjusted images
print("Adjusted Color Image:")
cv2_imshow(adjusted_color_img)
print("Adjusted Grayscale Image:")
cv2_imshow(adjusted_gray_img)
print("Adjusted Black Image:")
cv2_imshow(adjusted_black_img)

# Find digital negative of the image
negative_color_img = 255 - adjusted_color_img
negative_gray_img = 255 - adjusted_gray_img
negative_black_img = 255 - adjusted_black_img

# Display digital negative images
print("Color Digital Negative Image:")
cv2_imshow(negative_color_img)
print("Grayscale Digital Negative Image:")
cv2_imshow(negative_gray_img)
print("Black Digital Negative Image:")
cv2_imshow(negative_black_img)

# Get the red, green, and blue values of each pixel
print("RGB values of the first 10x10 pixels of the negative color image:")
for y in range(10):
    for x in range(10):
        b, g, r = negative_color_img[y, x]
        print(f"Pixel at ({x},{y}): R={r}, G={g}, B={b}")


# Subtract each color value from 255 and save them as new color values
# Create new pixel values for color image
height, width, channels = negative_color_img.shape
new_pixel_values = np.zeros_like(negative_color_img)

for y in range(height):
    for x in range(width):
        b, g, r = negative_color_img[y, x]
        new_b = 255 - b
        new_g = 255 - g
        new_r = 255 - r
        new_pixel_values[y, x] = [new_b, new_g, new_r]

# Save the new image
output_path_new = '/content/new_pixel_values.jpg'
cv2.imwrite(output_path_new, new_pixel_values)

# Display the new image
print("New Pixel Values Image:")
cv2_imshow(new_pixel_values)

# Plot results using OpenCV
print("Plotting results...")
cv2_imshow(color_img)
cv2_imshow(adjusted_color_img)
cv2_imshow(negative_color_img)
cv2_imshow(new_pixel_values)

# Practical 06 :-
# 1) Perform Boundary Detection on image

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Read the image
image = cv2.imread('/content/download (3).jpg')

# Step 2: Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Step 3: Apply Gaussian Blur
blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# Step 4: Use Canny Edge Detection
edges = cv2.Canny(blurred, 50, 150)

# Step 5: Find Contours
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Step 6: Draw Contours
# Option 1: Draw contours on the original image
contour_image = image.copy()
cv2.drawContours(contour_image, contours, -1, (255, 255, 255), 2)

# Option 2: Draw contours on a blank image
blank_image = np.zeros_like(image)
cv2.drawContours(blank_image, contours, -1, (255, 255, 255), 2)

# Display the results
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title('Contours on Original Image')
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))

plt.subplot(1, 2, 2)
plt.title('Contours on Blank Image')
plt.imshow(cv2.cvtColor(blank_image, cv2.COLOR_BGR2RGB))

plt.show()


# 2) To find Discrete Consine Transform
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Step 2: Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Step 3: Apply DCT
dct = cv2.dct(np.float32(gray))

# For better visualization, use a logarithmic scale
dct_log = np.log(abs(dct) + 1)

# Normalize the DCT image to the range [0, 255] for display
dct_norm = cv2.normalize(dct_log, None, 0, 255, cv2.NORM_MINMAX)
dct_norm = np.uint8(dct_norm)

# Display the results
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title('Original Grayscale Image')
plt.imshow(gray, cmap='gray')

plt.subplot(1, 2, 2)
plt.title('DCT of Image (Log Scale)')
plt.imshow(dct_norm, cmap='gray')

plt.show()


# 3) To use Haar Transform object detection

import cv2
import matplotlib.pyplot as plt

# Step 1: Load the Haar cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Step 2: Read the image
image = cv2.imread('/content/download (3).jpg')

# Step 3: Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Step 4: Detect faces
faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE)

# Step 5: Draw rectangles around the detected faces
for (x, y, w, h) in faces:
    cv2.rectangle(image, (x, y), (x + w, y + h), (255, 0, 0), 2)

# Display the result
plt.figure(figsize=(10, 5))
plt.title('Detected Faces')
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.axis('off')
plt.show()

# Practical 07 :- Perform Image Compression (Lossy and Lossless)
# Import necessary libraries
from google.colab import files
import cv2, os, numpy as np
from PIL import Image
import matplotlib.pyplot as plt

# Load the image and convert to RGB for Pillow and plotting
file_name = '/content/file_example_TIFF_1MB.tiff'
image = cv2.imread(file_name)
image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Save images with lossless (PNG) and lossy (JPEG) compression
Image.fromarray(image_rgb).save('compressed_image_lossless.png', format='PNG', optimize=True)
cv2.imwrite('compressed_image_lossy.jpg', image, [int(cv2.IMWRITE_JPEG_QUALITY), 80])

# Load compressed images
image_lossless = cv2.imread('compressed_image_lossless.png')
image_lossy = cv2.imread('compressed_image_lossy.jpg')
image_lossless_rgb = cv2.cvtColor(image_lossless, cv2.COLOR_BGR2RGB)
image_lossy_rgb = cv2.cvtColor(image_lossy, cv2.COLOR_BGR2RGB)

# Function to calculate PSNR (Peak Signal-to-Noise Ratio)
def calculate_psnr(original, compressed):
    mse = np.mean((original - compressed) ** 2)
    return float('inf') if mse == 0 else 20 * np.log10(255.0 / np.sqrt(mse))

# Get details: file sizes, dimensions, PSNR values
get_size = lambda path: os.path.getsize(path) / 1024
psnr_lossless = calculate_psnr(image, image_lossless)
psnr_lossy = calculate_psnr(image, image_lossy)
dimensions = f"{image.shape[1]} x {image.shape[0]}"

# Plot original, lossless, and lossy images with details
plt.figure(figsize=(18, 8))
for idx, (img, title, size, psnr) in enumerate([
    (image_rgb, 'Original Image', get_size(file_name), 'N/A'),
    (image_lossless_rgb, 'Lossless Compression (PNG)', get_size('compressed_image_lossless.png'), f'{psnr_lossless:.2f}'),
    (image_lossy_rgb, 'Lossy Compression (JPEG)', get_size('compressed_image_lossy.jpg'), f'{psnr_lossy:.2f}')
]):
    plt.subplot(1, 3, idx + 1)
    plt.title(f'{title}\nSize: {size:.2f} KB\nDimensions: {dimensions}\nPSNR: {psnr}')
    plt.imshow(img)
    plt.axis('off')
plt.show()

import cv2
from google.colab.patches import cv2_imshow
from matplotlib import pyplot as plt
import os

# File path for the TIFF image
tiff_image_path = '/content/file_example_TIFF_1MB.tiff'

# Load the TIFF image
img = cv2.imread(tiff_image_path, cv2.IMREAD_UNCHANGED)

# Save as lossless PNG
cv2.imwrite('lossless_compressed_image.png', img)

# Save as lossy JPEG
jpeg_quality = 90  # A value between 0 and 100 (higher means better quality, but larger file size)
cv2.imwrite('lossy_compressed_image.jpg', img, [cv2.IMWRITE_JPEG_QUALITY, jpeg_quality])

# Get sizes of the files
original_size = os.path.getsize(tiff_image_path)
lossless_size = os.path.getsize('lossless_compressed_image.png')
lossy_size = os.path.getsize('lossy_compressed_image.jpg')

print(f'Original image size: {original_size} bytes')
print(f'Lossless compressed image size: {lossless_size} bytes')
print(f'Lossy compressed image size: {lossy_size} bytes')

# Load images for display
img = cv2.imread(tiff_image_path, cv2.IMREAD_UNCHANGED)
lossless_img = cv2.imread('lossless_compressed_image.png')
lossy_img = cv2.imread('lossy_compressed_image.jpg')

# Convert BGR to RGB for Matplotlib
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
lossless_img_rgb = cv2.cvtColor(lossless_img, cv2.COLOR_BGR2RGB)
lossy_img_rgb = cv2.cvtColor(lossy_img, cv2.COLOR_BGR2RGB)

# Create a figure and a set of subplots
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# Original Image
axes[0].imshow(img_rgb)
axes[0].set_title('Original Image')
axes[0].axis('off')  # Hide axes

# Lossless Compressed Image
axes[1].imshow(lossless_img_rgb)
axes[1].set_title('Lossless Compressed Image')
axes[1].axis('off')  # Hide axes

# Lossy Compressed Image
axes[2].imshow(lossy_img_rgb)
axes[2].set_title('Lossy Compressed Image')
axes[2].axis('off')  # Hide axes

# Display the plot
plt.show()

# Function to plot the histogram for an image
def plot_histogram(image, title):
    channels = cv2.split(image)
    colors = ('b', 'g', 'r')  # Blue, Green, Red
    plt.figure(figsize=(10, 6))
    for channel, color in zip(channels, colors):
        histogram = cv2.calcHist([channel], [0], None, [256], [0, 256])
        plt.plot(histogram, color=color, label=f'{color.upper()} channel')

    plt.title(title)
    plt.xlabel('Intensity Value (0-255)')
    plt.ylabel('Frequency')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Step 5: Plot the histograms for the original, lossless, and lossy images
plot_histogram(img, 'Original Image - Color Histogram')
plot_histogram(lossless_img, 'Lossless Image (PNG) - Color Histogram')
plot_histogram(lossy_img, 'Lossy Image (JPEG) - Color Histogram')

import cv2
import numpy as np
from IPython.display import display, clear_output
from PIL import Image
from io import BytesIO

# Load the pre-trained Haar Cascade classifier for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Initialize the webcam
cap = cv2.VideoCapture(1)

def detect_faces():
    frame_count = 0  # Counter to limit the number of frames for demo purposes
    max_frames = 50  # Set a limit on how many frames to process

    while frame_count < max_frames:
        # Capture frame-by-frame
        ret, frame = cap.read()

        if not ret:
            print("Failed to grab frame")
            break

        # Convert the frame to grayscale
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Detect faces in the grayscale image
        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

        # Draw rectangles around the faces
        for (x, y, w, h) in faces:
            cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)

        # Convert frame to RGB and display it
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        display_image(frame_rgb)

        frame_count += 1  # Increment the frame count

    # Release the capture (no need for cv2.destroyAllWindows in Jupyter)
    cap.release()

def display_image(image):
    """Displays the image in Jupyter Notebook."""
    # Convert image to PIL format
    pil_image = Image.fromarray(image)

    # Convert PIL image to BytesIO object
    buf = BytesIO()
    pil_image.save(buf, format='PNG')

    # Display image in the notebook
    display.display(display.Image(data=buf.getvalue()))
    clear_output(wait=True)

# Call the function to start face detection
detect_faces()

!pip install opencv-python
!pip install matplotlib
!pip install numpy

#===========live Detection =====================================================================
import cv2
import numpy as np

# Load the Haar cascade for face detection
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Start capturing video from the webcam
cap = cv2.VideoCapture(0)  # 0 is usually the default camera

while True:
    # Capture frame-by-frame
    ret, frame = cap.read()

    if not ret:
        break  # If there's an error, break the loop

    # Resize the frame for a consistent window size
    frame_resized = cv2.resize(frame, (400, 300))

    # Convert the frame to grayscale
    gray = cv2.cvtColor(frame_resized, cv2.COLOR_BGR2GRAY)

    # Detect faces in the grayscale frame
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    # Create a copy of the original frame for face detection display
    face_detection_frame = frame_resized.copy()

    # Draw rectangles around the faces
    for (x, y, w, h) in faces:
        cv2.rectangle(face_detection_frame, (x, y), (x + w, y + h), (0, 255, 0), 2)

    # Stack the images horizontally
    gray_bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)  # Convert grayscale to BGR for stacking
    stacked_frame = np.hstack((frame_resized, gray_bgr, face_detection_frame))

    # Display the stacked frame
    cv2.imshow('Original | Grayscale | Face Detection', stacked_frame)

    # Press 'q' to exit the loop
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video capture object and close all windows
cap.release()
cv2.destroyAllWindows()